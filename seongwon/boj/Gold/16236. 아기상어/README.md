# [Gold III] 아기 상어 - 16236

[문제 링크](https://www.acmicpc.net/problem/16236)

### 성능 요약

메모리: 14732 KB, 시간: 136 ms

### 분류

너비 우선 탐색, 그래프 이론, 그래프 탐색, 구현, 시뮬레이션

### 문제 설명

<p>N×N 크기의 공간에 물고기 M마리와 아기 상어 1마리가 있다. 공간은 1×1 크기의 정사각형 칸으로 나누어져 있다. 한 칸에는 물고기가 최대 1마리 존재한다.</p>

<p>아기 상어와 물고기는 모두 크기를 가지고 있고, 이 크기는 자연수이다. 가장 처음에 아기 상어의 크기는 2이고, 아기 상어는 1초에 상하좌우로 인접한 한 칸씩 이동한다.</p>

<p>아기 상어는 자신의 크기보다 큰 물고기가 있는 칸은 지나갈 수 없고, 나머지 칸은 모두 지나갈 수 있다. 아기 상어는 자신의 크기보다 작은 물고기만 먹을 수 있다. 따라서, 크기가 같은 물고기는 먹을 수 없지만, 그 물고기가 있는 칸은 지나갈 수 있다.</p>

<p>아기 상어가 어디로 이동할지 결정하는 방법은 아래와 같다.</p>

<ul>
	<li>더 이상 먹을 수 있는 물고기가 공간에 없다면 아기 상어는 엄마 상어에게 도움을 요청한다.</li>
	<li>먹을 수 있는 물고기가 1마리라면, 그 물고기를 먹으러 간다.</li>
	<li>먹을 수 있는 물고기가 1마리보다 많다면, 거리가 가장 가까운 물고기를 먹으러 간다.
	<ul>
		<li>거리는 아기 상어가 있는 칸에서 물고기가 있는 칸으로 이동할 때, 지나야하는 칸의 개수의 최솟값이다.</li>
		<li>거리가 가까운 물고기가 많다면, 가장 위에 있는 물고기, 그러한 물고기가 여러마리라면, 가장 왼쪽에 있는 물고기를 먹는다.</li>
	</ul>
	</li>
</ul>

<p>아기 상어의 이동은 1초 걸리고, 물고기를 먹는데 걸리는 시간은 없다고 가정한다. 즉, 아기 상어가 먹을 수 있는 물고기가 있는 칸으로 이동했다면, 이동과 동시에 물고기를 먹는다. 물고기를 먹으면, 그 칸은 빈 칸이 된다.</p>

<p>아기 상어는 자신의 크기와 같은 수의 물고기를 먹을 때 마다 크기가 1 증가한다. 예를 들어, 크기가 2인 아기 상어는 물고기를 2마리 먹으면 크기가 3이 된다.</p>

<p>공간의 상태가 주어졌을 때, 아기 상어가 몇 초 동안 엄마 상어에게 도움을 요청하지 않고 물고기를 잡아먹을 수 있는지 구하는 프로그램을 작성하시오.</p>

### 입력

 <p>첫째 줄에 공간의 크기 N(2 ≤ N ≤ 20)이 주어진다.</p>

<p>둘째 줄부터 N개의 줄에 공간의 상태가 주어진다. 공간의 상태는 0, 1, 2, 3, 4, 5, 6, 9로 이루어져 있고, 아래와 같은 의미를 가진다.</p>

<ul>
	<li>0: 빈 칸</li>
	<li>1, 2, 3, 4, 5, 6: 칸에 있는 물고기의 크기</li>
	<li>9: 아기 상어의 위치</li>
</ul>

<p>아기 상어는 공간에 한 마리 있다.</p>

### 출력

 <p>첫째 줄에 아기 상어가 엄마 상어에게 도움을 요청하지 않고 물고기를 잡아먹을 수 있는 시간을 출력한다.</p>

### 풀이

아기상어 행동 규칙

1. 더 이상 먹을 수 있는 물고기가 없다면 엄마상어에게 감 (종료)
2. 먹을 수 있는 물고기가 1마리라면, 그 물고기를 먹으러감
3. 먹을 수 있는 물고기가 2마리 이상이면 가까운 물고기를 먹으러감

- 이동 우선 순위 상 -> 좌 -> 우 -> 하
- 아기상어는 자신의 크기 만큼 물고기를 먹으면 크기가 증가

위의 조건들을 이행해야 하며 문제가 될 수 있는 조건들을 생각해 봐야 합니다.

1. 먹이가 가로 막혀있어 먹을 수 없는 경우
   ```
   1 3 0
   3 0 0
   0 0 9
   ```
2. 상어가 막혀있어 먹이를 먹을 수 없는 경우
   `1 1 1
1 1 3
1 3 9`
   에 대한 대처가 필요하며 탐색 우선 순위에 대해서도 고민할 필요가 있습니다
   단순히 상 -> 좌 -> 우 -> 하 순으로 검색을 하게되면 아래와 같이 탐색하게 됩니다.

```
		5
	6	1	7
8	2	a	3	10
    9	4	11
		12
```

하지만 올바른 탐색 순서는 아래와 같이 진행되어야 합니다.

```
		5
	6	1	7
8	2	a	3	9
    10	4	11
		12
```

### 풀이 코드

```java
	/**
	 * 상어를 이동하며 먹이활동 구현
	 */
	public static void moveShark() {
		/* BFS 탐색을 이용하여 가까운 먹이를 먹을 수 있도록 하며 탐색의 우선순위를 정해주어야함 */
		PriorityQueue<int[]> queue = new PriorityQueue<>((o1, o2) -> {
			// 거리가 같다면 상 좌 우 하의 순서로 정렬
			if (o1[2] == o2[2]) {
				// 높이가 같다면 좌 우 순서 정렬
				if (o1[0] == o2[0])
					return Integer.compare(o1[1], o2[1]);
					// 상 하 정렬
				return Integer.compare(o1[0], o2[0]);
			}
			// 거리순으로 정렬
			return Integer.compare(o1[2], o2[2]);
		});
		// 방문 초기화
		visited = new boolean[N][N];
		int x = sx;
		int y = sy;
		// 현재 좌표 방문 체크
		visited[x][y] = true;
		// 초기 좌표 Q에 PUSH
		queue.add(new int[] { x, y, 0 });
		// queue가 비어있으면 종료
		while (!queue.isEmpty()) {
			int[] loc = queue.poll();

			for (int i = 0; i < 4; i++) {
				int nx = loc[0] + dx[i];
				int ny = loc[1] + dy[i];
				/* 맵에서 벗어나지 않고 물고기의 크기가 상어의 크기보다 작을 때만 이동 */
				if (nx >= 0 && ny >= 0 && nx < N && ny < N && map[nx][ny] <= sSize && !visited[nx][ny]) {
					visited[nx][ny] = true;
					queue.add(new int[] { nx, ny, loc[2] + 1 });
				}
			}

			/* 현재 좌표에 먹을 수 있는 먹이가 있다면 먹이 활동
			 * 주의 해야할 점은 상어의 크기가 9를 넘어서게 되면 자기자신을 계속 먹게되어 무한루프 발생 때문에 조건에 주의해야함 */
			if (map[loc[0]][loc[1]] != 0 && map[loc[0]][loc[1]] < sSize && map[loc[0]][loc[1]] != 9) {
				map[sx][sy] = 0; // 먹은 물고기 map에서 지우기
				sx = loc[0]; // 상어 좌표 갱신
				sy = loc[1];
				fishArr[map[sx][sy]]--; // 남은 먹이 감소
				answer += loc[2]; // 시간에 먹이를 먹기까지의 거리 추가
				eat++; // 먹은 갯수 증가
				if (eat == sSize) { // 먹은 갯수가 상어의 크기와 같다면 사이즈업
					eat = 0;
					sSize++;
				}
				map[sx][sy] = 9; // 상어 좌표에 상어 입력
				break;
			}
		}
	}
```
